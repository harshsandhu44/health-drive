# HealthDrive Supabase Database Schema and Setup

This document outlines the updated Supabase database schema for the HealthDrive B2B SaaS
application, including table definitions, relationships, and setup instructions using the
`@supabase/ssr` package for Next.js 15. The schema supports the management of organizations, users,
doctors, departments, appointments, patients, patient records, and analytics logs, with a focus on
real-time updates and privacy for patient data. Updates include using `text` for `organization_id`,
`user_id`, `Organizations.id`, `Users.id`, and `Doctors.id` to align with Clerk IDs and
autogeneration for `Doctors.id`.

## 1. Database Schema

### 1.1 Tables

#### Organizations

Stores information about healthcare facilities (organizations) using HealthDrive.

- **Fields**:
  - `id` (text, primary key) — Clerk organization ID
  - `name` (varchar, not null)
  - `billing_status` (varchar, default: 'inactive', options: 'active', 'inactive', 'past_due')
  - `created_at` (timestamp, default: `now()`)
- **Purpose**: Tracks facilities and their subscription status.

#### Users

Stores user accounts associated with organizations.

- **Fields**:
  - `id` (text, primary key) — Clerk user ID
  - `organization_id` (text, foreign key to `Organizations.id`, not null)
  - `email` (varchar, not null, unique)
  - `role` (varchar, not null, options: 'admin', 'staff', 'doctor')
  - `created_at` (timestamp, default: `now()`)
- **Purpose**: Manages user authentication and roles within facilities.

#### Departments

Stores department information for each organization.

- **Fields**:
  - `id` (uuid, primary key, default: `gen_random_uuid()`)
  - `organization_id` (text, foreign key to `Organizations.id`, not null)
  - `name` (varchar, not null)
- **Purpose**: Organizes doctors by department (e.g., Cardiology, Neurology).

#### Doctors

Stores doctor profiles for each organization.

- **Fields**:
  - `id` (text, primary key, default: `gen_random_uuid()::text`) — Autogenerated text ID
  - `organization_id` (text, foreign key to `Organizations.id`, not null)
  - `department_id` (uuid, foreign key to `Departments.id`, nullable)
  - `name` (varchar, not null)
  - `contact` (varchar, nullable)
  - `specialization` (varchar, nullable)
- **Purpose**: Manages doctor details and assignments.

#### Patients

Stores patient information for secure record access.

- **Fields**:
  - `id` (uuid, primary key, default: `gen_random_uuid()`)
  - `phone_number` (varchar, not null, unique)
  - `name` (varchar, not null)
  - `date_of_birth` (date, not null)
  - `blood_group` (varchar, not null, options: 'A+', 'A-', 'B+', 'B-', 'AB+', 'AB-', 'O+', 'O-')
- **Purpose**: Stores core patient data for appointment and record management.

#### Appointments

Stores appointment details for scheduling.

- **Fields**:
  - `id` (uuid, primary key, default: `gen_random_uuid()`)
  - `organization_id` (text, foreign key to `Organizations.id`, not null)
  - `doctor_id` (text, foreign key to `Doctors.id`, nullable)
  - `patient_id` (uuid, foreign key to `Patients.id`, not null)
  - `date` (date, not null)
  - `time` (time, not null)
  - `status` (varchar, not null, default: 'pending', options: 'pending', 'confirmed', 'completed',
    'cancelled')
- **Purpose**: Manages appointment scheduling and status updates.

#### Patient_Records

Stores medical history for patients.

- **Fields**:
  - `id` (uuid, primary key, default: `gen_random_uuid()`)
  - `patient_id` (uuid, foreign key to `Patients.id`, not null)
  - `medical_history` (text, nullable)
  - `last_updated` (timestamp, default: `now()`)
- **Purpose**: Maintains secure, shared patient medical records.

#### Analytics_Logs

Stores analytics data for reporting.

- **Fields**:
  - `id` (uuid, primary key, default: `gen_random_uuid()`)
  - `organization_id` (text, foreign key to `Organizations.id`, not null)
  - `metric_type` (varchar, not null, options: 'total_appointments', 'appointments_per_doctor',
    'returning_patients')
  - `value` (integer, not null)
  - `timestamp` (timestamp, default: `now()`)
- **Purpose**: Tracks metrics for real-time analytics.

### 1.2 Relationships

- `Users.organization_id` → `Organizations.id` (Many-to-One)
- `Departments.organization_id` → `Organizations.id` (Many-to-One)
- `Doctors.organization_id` → `Organizations.id` (Many-to-One)
- `Doctors.department_id` → `Departments.id` (Many-to-One, nullable)
- `Appointments.organization_id` → `Organizations.id` (Many-to-One)
- `Appointments.doctor_id` → `Doctors.id` (Many-to-One, nullable)
- `Appointments.patient_id` → `Patients.id` (Many-to-One)
- `Patient_Records.patient_id` → `Patients.id` (Many-to-One)
- `Analytics_Logs.organization_id` → `Organizations.id` (Many-to-One)

## 2. Supabase Setup Instructions

### 2.1 Create Supabase Project

1. Sign up or log in to [Supabase](https://supabase.com).
2. Create a new project:
   - Navigate to the Supabase Dashboard.
   - Click "New Project" and select your organization.
   - Enter project name (e.g., `HealthDrive`).
   - Choose a region and set a secure password.
3. Wait for the project to initialize (takes ~2 minutes).
4. Note the **Project URL** and **API Key** (anon public key) from the API settings.

### 2.2 Create Tables

Use the Supabase SQL Editor or Table Editor to create tables. Below is the updated SQL for each
table, reflecting `text` types for Clerk IDs and `Doctors.id`.

```sql
-- Organizations
CREATE TABLE organizations (
  id TEXT PRIMARY KEY,
  name VARCHAR NOT NULL,
  billing_status VARCHAR DEFAULT 'inactive' CHECK (billing_status IN ('active', 'inactive', 'past_due')),
  created_at TIMESTAMP DEFAULT now()
);

-- Users
CREATE TABLE users (
  id TEXT PRIMARY KEY,
  organization_id TEXT NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  email VARCHAR NOT NULL UNIQUE,
  role VARCHAR NOT NULL CHECK (role IN ('admin', 'staff', 'doctor')),
  created_at TIMESTAMP DEFAULT now()
);

-- Departments
CREATE TABLE departments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id TEXT NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  name VARCHAR NOT NULL
);

-- Doctors
CREATE TABLE doctors (
  id TEXT PRIMARY KEY DEFAULT gen_random_uuid()::text,
  organization_id TEXT NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  department_id UUID REFERENCES departments(id) ON DELETE SET NULL,
  name VARCHAR NOT NULL,
  contact VARCHAR,
  specialization VARCHAR
);

-- Patients
CREATE TABLE patients (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  phone_number VARCHAR NOT NULL UNIQUE,
  name VARCHAR NOT NULL,
  date_of_birth DATE NOT NULL,
  blood_group VARCHAR NOT NULL CHECK (blood_group IN ('A+', 'A-', 'B+', 'B-', 'AB+', 'AB-', 'O+', 'O-'))
);

-- Appointments
CREATE TABLE appointments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id TEXT NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  doctor_id TEXT REFERENCES doctors(id) ON DELETE SET NULL,
  patient_id UUID NOT NULL REFERENCES patients(id) ON DELETE CASCADE,
  date DATE NOT NULL,
  time TIME NOT NULL,
  status VARCHAR NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'confirmed', 'completed', 'cancelled'))
);

-- Patient_Records
CREATE TABLE patient_records (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  patient_id UUID NOT NULL REFERENCES patients(id) ON DELETE CASCADE,
  medical_history TEXT,
  last_updated TIMESTAMP DEFAULT now()
);

-- Analytics_Logs
CREATE TABLE analytics_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id TEXT NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  metric_type VARCHAR NOT NULL CHECK (metric_type IN ('total_appointments', 'appointments_per_doctor', 'returning_patients')),
  value INTEGER NOT NULL,
  timestamp TIMESTAMP DEFAULT now()
);
```

1. Open the Supabase Dashboard.
2. Navigate to **SQL Editor**.
3. Copy and paste the above SQL, then click **Run**.
4. Verify tables in the **Table Editor**.

### 2.3 Enable Real-Time Subscriptions

Real-time updates are required for appointments and analytics.

1. Go to **Database** > **Replication** in the Supabase Dashboard.
2. Enable replication for:
   - `appointments`
   - `analytics_logs`
3. Click **Save** to activate real-time subscriptions.

### 2.4 Configure Row Level Security (RLS)

RLS ensures data privacy, especially for patient records and organization-specific data.

#### Enable RLS

1. Go to **Authentication** > **Policies** in the Supabase Dashboard.
2. Enable RLS for all tables:
   - `organizations`
   - `users`
   - `departments`
   - `doctors`
   - `patients`
   - `appointments`
   - `patient_records`
   - `analytics_logs`

#### Create RLS Policies

Use the SQL Editor to create policies. The policies are updated to use `text` for `id` fields.

```sql
-- Organizations: Only users in the organization can view/edit
CREATE POLICY org_access ON organizations
  FOR ALL
  USING (id = (SELECT organization_id FROM users WHERE id = auth.uid()))
  WITH CHECK (id = (SELECT organization_id FROM users WHERE id = auth.uid()));

-- Users: Only users in the same organization can view/edit
CREATE POLICY user_access ON users
  FOR ALL
  USING (organization_id = (SELECT organization_id FROM users WHERE id = auth.uid()))
  WITH CHECK (organization_id = (SELECT organization_id FROM users WHERE id = auth.uid()));

-- Departments: Organization-specific access
CREATE POLICY dept_access ON departments
  FOR ALL
  USING (organization_id = (SELECT organization_id FROM users WHERE id = auth.uid()))
  WITH CHECK (organization_id = (SELECT organization_id FROM users WHERE id = auth.uid()));

-- Doctors: Organization-specific access
CREATE POLICY doctor_access ON doctors
  FOR ALL
  USING (organization_id = (SELECT organization_id FROM users WHERE id = auth.uid()))
  WITH CHECK (organization_id = (SELECT organization_id FROM users WHERE id = auth.uid()));

-- Patients: Only accessible via phone number match
CREATE POLICY patient_access ON patients
  FOR ALL
  USING (phone_number = (SELECT phone_number FROM patients WHERE id = (SELECT patient_id FROM appointments WHERE organization_id = (SELECT organization_id FROM users WHERE id = auth.uid()))))
  WITH CHECK (phone_number = (SELECT phone_number FROM patients WHERE id = (SELECT patient_id FROM appointments WHERE organization_id = (SELECT organization_id FROM users WHERE id = auth.uid()))));

-- Appointments: Organization-specific access
CREATE POLICY appt_access ON appointments
  FOR ALL
  USING (organization_id = (SELECT organization_id FROM users WHERE id = auth.uid()))
  WITH CHECK (organization_id = (SELECT organization_id FROM users WHERE id = auth.uid()));

-- Patient_Records: Only accessible via patient_id linked to organization
CREATE POLICY record_access ON patient_records
  FOR ALL
  USING (patient_id IN (SELECT patient_id FROM appointments WHERE organization_id = (SELECT organization_id FROM users WHERE id = auth.uid())))
  WITH CHECK (patient_id IN (SELECT patient_id FROM appointments WHERE organization_id = (SELECT organization_id FROM users WHERE id = auth.uid())));

-- Analytics_Logs: Organization-specific access
CREATE POLICY analytics_access ON analytics_logs
  FOR ALL
  USING (organization_id = (SELECT organization_id FROM users WHERE id = auth.uid()))
  WITH CHECK (organization_id = (SELECT organization_id FROM users WHERE id = auth.uid()));
```

1. Run the above SQL in the **SQL Editor**.
2. Verify policies in the **Policies** section of the Supabase Dashboard.

### 2.5 Clerk Webhook Integration

To sync organizations and users from Clerk to Supabase in an SSR context:

1. Create a webhook endpoint in your Next.js app (e.g., `/api/clerk-webhook`).
2. Use `@supabase/ssr` for server-side Supabase operations.
3. Configure the endpoint to handle Clerk events (`user.created`, `organization.created`).
4. In Supabase Dashboard:
   - Go to **Settings** > **API** and copy the **Project URL** and **Service Role Key**.
   - Store these in your Next.js environment variables (`.env.local`).
5. In Clerk Dashboard:
   - Add the webhook URL (`https://your-app.com/api/clerk-webhook`).
   - Enable events for `user.created` and `organization.created`.

Example webhook handler using `@supabase/ssr` in a Next.js API route:

```javascript
import { createServerClient } from "@supabase/ssr";

export async function POST(req) {
  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL,
    process.env.SUPABASE_SERVICE_ROLE_KEY,
    {
      cookies: {
        getAll() {
          return [];
        },
        setAll() {},
      },
    }
  );

  const event = await req.json();
  if (event.type === "organization.created") {
    const { error } = await supabase.from("organizations").insert({
      id: event.data.id,
      name: event.data.name,
      billing_status: "inactive",
    });
    if (error) throw error;
  } else if (event.type === "user.created") {
    const { error } = await supabase.from("users").insert({
      id: event.data.id,
      organization_id: event.data.organization_id,
      email: event.data.email_addresses[0].email_address,
      role: "staff", // Default role
    });
    if (error) throw error;
  }
  return new Response("Success", { status: 200 });
}
```

### 2.6 Initialize Supabase Client

Install the `@supabase/ssr` package:

```bash
npm install @supabase/ssr
```

Create a Supabase client utility for SSR in your Next.js app (e.g., `lib/supabase.ts`):

```javascript
import { createServerClient, createClient } from "@supabase/ssr";
import { cookies } from "next/headers";

// Server-side client for API routes or server components
export function createSupabaseServerClient() {
  const cookieStore = cookies();
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll();
        },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value, options }) => cookieStore.set(name, value, options));
        },
      },
    }
  );
}

// Client-side client for browser use
export function createSupabaseClient() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY
  );
}
```

### 2.7 Real-Time Configuration

To enable real-time updates in the Next.js app using `@supabase/ssr`, use the client-side client for
browser-based subscriptions (since real-time subscriptions are not supported in server components).

Example in a client component (e.g., `components/AppointmentsTable.tsx`):

```javascript
"use client";

import { useEffect } from "react";
import { createSupabaseClient } from "@/lib/supabase";

export default function AppointmentsTable({ initialData }) {
  useEffect(() => {
    const supabase = createSupabaseClient();

    // Subscribe to appointments
    const appointmentChannel = supabase
      .channel("appointments")
      .on("postgres_changes", { event: "*", schema: "public", table: "appointments" }, payload => {
        console.log("Appointment changed:", payload);
        // Update UI (e.g., refetch or update state)
      })
      .subscribe();

    // Subscribe to analytics_logs
    const analyticsChannel = supabase
      .channel("analytics_logs")
      .on(
        "postgres_changes",
        { event: "*", schema: "public", table: "analytics_logs" },
        payload => {
          console.log("Analytics updated:", payload);
          // Update UI
        }
      )
      .subscribe();

    // Cleanup on unmount
    return () => {
      supabase.removeChannel(appointmentChannel);
      supabase.removeChannel(analyticsChannel);
    };
  }, []);

  return <div>{/* Render appointments table */}</div>;
}
```

For server-side data fetching (e.g., in a Server Component):

```javascript
import { createSupabaseServerClient } from "@/lib/supabase";

export default async function Dashboard() {
  const supabase = createSupabaseServerClient();
  const { data: appointments, error } = await supabase
    .from("appointments")
    .select("*")
    .eq("date", new Date().toISOString().split("T")[0]);

  if (error) throw error;

  return <AppointmentsTable initialData={appointments} />;
}
```

### 2.8 Data Privacy for Patients

- **Phone Number Access**: The `patients` table uses RLS to restrict access to records based on
  phone number matches within the organization’s appointments.
- **Validation**: Sanitize phone number input in the Next.js app to prevent SQL injection.
- **Search Functionality**: Implement a patient search query using `@supabase/ssr` in a server
  context:

```javascript
import { createSupabaseServerClient } from "@/lib/supabase";

export async function searchPatient(phoneNumber) {
  const supabase = createSupabaseServerClient();
  const { data, error } = await supabase
    .from("patients")
    .select("id, name, date_of_birth, blood_group")
    .eq("phone_number", phoneNumber)
    .single();
  if (error) throw error;
  return data;
}
```

Use in an API route or Server Component:

```javascript
import { searchPatient } from "@/lib/patient";

export default async function PatientSearch({ searchParams }) {
  const phoneNumber = searchParams.phone;
  if (!phoneNumber) return <div>Enter a phone number</div>;

  try {
    const patient = await searchPatient(phoneNumber);
    return <div>Patient: {patient.name}</div>;
  } catch (error) {
    return <div>Patient not found</div>;
  }
}
```

### 2.9 Testing the Setup

1. Insert test data via the Supabase **Table Editor** or SQL, using text IDs for Clerk
   compatibility:

```sql
INSERT INTO organizations (id, name) VALUES ('org_123', 'Test Clinic');
INSERT INTO users (id, organization_id, email, role) VALUES ('user_456', 'org_123', 'admin@test.com', 'admin');
INSERT INTO departments (organization_id, name) VALUES ('org_123', 'Cardiology');
INSERT INTO doctors (organization_id, department_id, name, contact, specialization) VALUES ('org_123', (SELECT id FROM departments LIMIT 1), 'Dr. A', '123-456-7890', 'Heart Surgery');
INSERT INTO patients (phone_number, name, date_of_birth, blood_group) VALUES ('1234567890', 'John Doe', '1980-01-01', 'A+');
INSERT INTO appointments (organization_id, doctor_id, patient_id, date, time, status) VALUES ('org_123', (SELECT id FROM doctors LIMIT 1), (SELECT id FROM patients LIMIT 1), '2025-07-11', '10:00:00', 'confirmed');
INSERT INTO patient_records (patient_id, medical_history) VALUES ((SELECT id FROM patients LIMIT 1), 'Hypertension diagnosed in 2020');
INSERT INTO analytics_logs (organization_id, metric_type, value) VALUES ('org_123', 'total_appointments', 100);
```

2. Test real-time subscriptions in a client component using the `@supabase/ssr` client.
3. Verify RLS by attempting to access patient records with incorrect phone numbers.
4. Test server-side queries in API routes or Server Components, ensuring Clerk text IDs are
   correctly handled.

## 3. Notes

- **Indexes**: Consider adding indexes on frequently queried fields (e.g., `patients.phone_number`,
  `appointments.date`) for performance.
- **Backups**: Enable daily backups in Supabase Dashboard under **Database** > **Backups**.
- **Monitoring**: Use Supabase’s **Reports** to monitor query performance and real-time usage.
- **Security**: Store Supabase and Clerk keys in environment variables (`.env.local`):
  ```env
  NEXT_PUBLIC_SUPABASE_URL=your-supabase-url
  NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key
  SUPABASE_SERVICE_ROLE_KEY=your-service-key
  ```
- **SSR Considerations**: Use `createSupabaseServerClient` for server-side operations and
  `createSupabaseClient` for client-side real-time subscriptions. Avoid real-time subscriptions in
  server components, as they are not supported.
- **Clerk IDs**: Ensure Clerk organization and user IDs are correctly synced as `text` via the
  webhook. Validate ID formats in the webhook handler to prevent errors.

This schema and setup provide a robust foundation for HealthDrive’s data needs, optimized for
Next.js 15 with SSR using `@supabase/ssr` and Clerk text IDs.
